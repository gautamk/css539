\documentclass[12pt,conference]{IEEEtran}
%\documentclass[letterpaper,twocolumn,10pt]{article}

\usepackage{graphicx}
\usepackage{url}
\usepackage[usenames]{color}
\usepackage{listings}
\usepackage{dirtytalk}


%------------------------------------------------------------------------- 
% take the % away on next line to produce the final camera-ready version 
%\pagestyle{empty}

%------------------------------------------------------------------------- 
\begin{document}

\title{Limited use cryptographic tokens in securing cloud servers}


%for single author (just remove % characters)
\author{
{\rm Gautam Kumar, Brent Lagesse}\\
Computing and Software Systems\\
University of Washington Bothell\\
\{gautamk,lagesse\}@uw.edu
} % end author

\maketitle
\thispagestyle{empty}


\section*{Abstract}
\section*{Introduction}

The essence of securing cloud systems is using multiple layers \cite{panwar_layered_2011} of security to increase an attacker's cost for taking over the system. One of the possible layer of security is using moving target defences \cite{evans_effectiveness_2011}. 

In this paper we propose an implementation of moving target defence using ephemeral servers and a central trusted authority which acts on behalf an ephemeral server and proxies requests to sensitive resources such as database servers, caching servers and REST end points. Hash chains are used as an authentication mechanism by the central trusted authority. We take advantage of the limited use property of hash chains to secure authenticate ephemeral servers for a limited period of time.

\section*{Background}
\subsection*{Cryptographic hash function \cite{rogaway_cryptographic_2004}} 
A cryptographic hash function is any one way function which meets the following requirements 
\begin{itemize} 
\item Preimage resistance
\item Collision resistance
\item Second Preimage resistance
\end{itemize}

A hash function has preimage resistance if given a hash value $h$ it is computationally infeasible to find any message $m$ such that $h = hash(k,m)$ where $k$ is the hash key.

A hash function is collision resistant if, given two messages $m_{1}$ and $m_{2}$ it is hard to find a hash $h$ such that $h = hash(k,m_{1}) = hash(k,m_{2})$ where $k$ is the hash key.

A hash function has second pre-image resistance if given a message $m_{1}$ it is computationally infeasible to find a different message  $m_{2}$ such that $hash(k,m_{1}) = hash(k,m_{2})$ where $k$ is the hash key. The second pre-image resistance is a much harder property to achieve for hash functions. This property is closely related to the birthday problem \cite{lesser_exploring_1999}.

\begin{figure}[hbtp]
\includegraphics[scale=0.58]{hash_function.png}
\caption{A simplified view of a hash function which represents its input and potential result. The length of the hash sum always remains the same regardless of the input size. Any small change in the input drastically changes the output.}
\end{figure}


\subsection*{Hash Chains \cite{horne_hash_2011}}

Leslie Lamport \cite{lamport_password_1981} was first to propose the use of hash chains in his paper on a method for secure password authentication over an insecure medium.

\say{A hash chain is a sequence of values derived via consecutive applications of a cryptographic hash function to an initial input. Due to the properties of the hash function, it is relatively easy to calculate successive values in the chain but given a particular value,it is infeasible to determine the previous value} 

As an example, Let $x$ be the initial password a hash chain of length 2 would be $H^{2}(x) = H(H(x))$. So a hash chain of $n$ values is denoted as $H^{n}(x)$ and the $i^{th}$ value in the chain would be computed as $x_{i} = H(x_{i-1})$.

For a given value in the chain $x_{i}$ its computationally infeasible to determine the previous value in the chain $x_{i-1}$.

\section*{Potential threats}

According to OWASP's Top 10 security threats, \say{Sensitive data exposure} is the $6^{th}$ most critical type of security threat in web applications as of 2013 \cite{wichers_owasp_2014}. 

Sensitive data exposure simply refers to unintended exposure of sensitive information such as passwords, social security numbers, date of birth and so on. In the context of a cloud systems sensitive information may also include credentials to access a database, email server, REST API keys and so on. These credentials are usually stored as part of a configuration file which cloud servers can use to authenticate themselves with third party services within or outside the private cloud network. 

According to a report by Risk Based Security \cite{risk_based_executives_2014} \cite{shu_privacy-preserving_2015} the number of data leaks has dramatically increased from 2012 to 2013, to the tune of \$812 million. Though sensitive data exposure in the context of cloud configurations would only constitute a small part of these leaks, leaking of such credentials can potentially lead to massive data leaks or other potential vulnerabilities being exposed to potential attackers.

Sensitive data exposure can potentially be a consequence of other threats such as cross site scripting (XSS) \cite{louw_blueprint:_2009}, Injection is the most critical threat while XSS is the $3^{rd}$ most critical threat as classified by OWASP in 2013 \cite{wichers_owasp_2014}. 

\section*{Proposed solution architecture}

The proposed architecture to defend against the threat of sensitive data exposure is to use a Central Trusted Authority (CTA) responsible for storing sensitive information. The CTA would act as a proxy and would make requests on behalf of client facing servers, refer Fig. \ref{fig:architectureoverview}.

\begin{figure}[hbtp]
\includegraphics[scale=0.3]{overview_architecture.png}
\caption{Architectural overview of the system. This figure describes the three primary modules involved. The client facing server, The central trusted authority and a sensitive resource.}
\label{fig:architectureoverview} 
\end{figure}

The client facing servers would use hash chains to authenticate with the CTA. Hash chains cryptographically limit the number of times a key can be used. Limited use was intentionally selected to promote the creation of a moving target for attackers.

\subsection*{Assumptions}

\begin{figure*}[!ht]
  \centering
  \includegraphics[keepaspectratio=true,scale=0.8]{cta_architecture}
  \caption{Architecture of the Central Trusted Authority. The CTA consists of a storage backend, a hash chain verifier and a request proxy.}
  \label{fig:ctaarchitecture}
\end{figure*}


Client facing servers are the servers which are exposed outside the private cloud network environment. These client facing servers could potentially be load balancing servers, compute servers.

The client facing servers are assumed to be ephemeral. This is common in many cloud deployments \cite{vaquero_dynamically_2011} and contributes to the moving target nature of the security architecture. Companies such as netflix expect this behaviour with their chaos engineering architecture \cite{basiri_chaos_2016}. This allows for higher reliability of their server infrastructure.

Client facing servers are expected to shut down after their hash chain expires. This contributes to the ephemeral nature and also to moving target defence of the overall system.

\subsection*{CTA Architecture and Implementation}

The Central Trusted Authority consists of three primary components, A hash chain verifier, A storage backend and a request proxy. The CTA generally performs three roles within the system which are

\begin{itemize}
\item Create new hash chain
\item Verify hash chains
\item Proxy requests for a client facing server.
\end{itemize}

\subsubsection*{Creating new hash chain}
Hash chains are created by iteratively hashing a secret key $K$, $n$ number of times. 
After the hash chain is created the CTA stores $H^{100}(K)$ in the storage backend and returns $K$ and $n$ to the client facing server. The secret key $K$ is not stored by the CTA.

The client facing server can now use the the secret key $n$ number of times.

\subsubsection*{Hash chain verification}
Hash chains are used to authenticate client facing server requests which require access to a sensitive resource. The hash chain verification process consists of four steps, Receive hash chain secret, compute the hash sum of the chain secret and verify with the storage backend.

The storage backend stores the last verified key $H^{i}$ of the hash chain where $i$ is the last verified index of the hash chain. When initializing the hash chain $i = n$. 

\begin{itemize}
\item Receive hash chain secret $H^{i-1}(K)$ from the client.
\item Compute $H^{i}$ by $H^{i} = H(H^{i-1}(K))$

\item If the computed $H^{i}$ equals the value in the storage backend
\begin{itemize}
\item Replace $H^{i}$ with $H^{i-1}(K)$.
\end{itemize}
\item Else reject the key and refuse connection.
\end{itemize}

\section*{Performance testing}

\section*{Potential issues}
- Hash chain vulnerabilities \cite{lee_hash_2007}

\section*{Future work}

- Timed release \cite{chalkias_timed_2006}
- 

\section*{Related work}



\bibliographystyle{plain}
\bibliography{css539_class_see}

\end{document}

